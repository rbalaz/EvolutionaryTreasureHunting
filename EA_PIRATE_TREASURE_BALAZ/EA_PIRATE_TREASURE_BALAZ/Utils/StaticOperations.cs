using PirateTreasure.Evolution_algorithm_blocks;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace PirateTreasure.Utils
{
    static class StaticOperations
    {
        public static double Point2DDistance(Point first, Point second)
        {
            return Math.Sqrt(Math.Pow(first.X - second.X, 2) + Math.Pow(first.Y - second.Y, 2));
        }

        public static bool ValidatePath(Path path)
        {
            // Tests validity of path generated by genetic operators
            // Path must comply to a 3 simple rules:
            // 1. EVERY NEIGHBOURING POINTS MUST HAVE EXACTLY ONE DIFFERENT COORDINATE BY ONE POINT
            for (int i = 0; i < path.Points.Count - 1; i++)
            {
                double xDifference = path.Points[i + 1].X - path.Points[i].X;
                double yDifference = path.Points[i + 1].Y - path.Points[i].Y;

                if (xDifference < 0 || xDifference > 1)
                    return false;
                if (yDifference < 0 || yDifference > 1)
                    return false;
                if (xDifference == 1 && yDifference == 1)
                    return false;
                if (xDifference == 0 && yDifference == 0)
                    return false;
            }

            // 2. PATH NEEDS TO CONTAIN EXACTLY 69 POINTS
            if (path.Points.Count != 69)
                return false;

            // 3. PATH NEEDS TO START IN (1,1) AND END IN (40,30)
            if (path.Points[0].X != 1 || path.Points[0].Y != 1)
                return false;
            if (path.Points[68].X != 40 || path.Points[68].Y != 30)
                return false;

            return true;
        }

        public static bool ValidatePath(List<int> points)
        {
            Representation representation = new Representation(points);
            Decoder decoder = new Decoder();
            return ValidatePath(decoder.DecodeRepresentation(representation));
        }
    }
}
